{"message":"unused import: `c2rust_out::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":195,"byte_end":208,"line_start":11,"line_end":11,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"use c2rust_out::*;","highlight_start":5,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":191,"byte_end":209,"line_start":11,"line_end":11,"column_start":1,"column_end":19,"is_primary":true,"text":[{"text":"use c2rust_out::*;","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `c2rust_out::*`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:11:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse c2rust_out::*;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"unused variable: `i`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":5640,"byte_end":5641,"line_start":231,"line_end":231,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"        let mut i: u64 = 0;","highlight_start":17,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":5640,"byte_end":5641,"line_start":231,"line_end":231,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"        let mut i: u64 = 0;","highlight_start":17,"highlight_end":18}],"label":null,"suggested_replacement":"_i","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `i`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:231:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m231\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut i: u64 = 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_i`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_variables)]` on by default\u001b[0m\n\n"}
{"message":"unused variable: `ri`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":5668,"byte_end":5670,"line_start":232,"line_end":232,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"        let mut ri: f64 = 0.0f64;","highlight_start":17,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":5668,"byte_end":5670,"line_start":232,"line_end":232,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"        let mut ri: f64 = 0.0f64;","highlight_start":17,"highlight_end":19}],"label":null,"suggested_replacement":"_ri","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `ri`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:232:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m232\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut ri: f64 = 0.0f64;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_ri`\u001b[0m\n\n"}
{"message":"dereference of raw pointer is unsafe and requires unsafe function or block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `allow` by default but will be upgraded to `warn` in a future edition.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6909,"byte_end":6927,"line_start":264,"line_end":264,"column_start":9,"column_end":27,"is_primary":true,"text":[{"text":"        (*q).q[0 as usize],","highlight_start":9,"highlight_end":27}],"label":"dereference of raw pointer","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0133]\u001b[0m\u001b[0m\u001b[1m: dereference of raw pointer is unsafe and requires unsafe function or block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:264:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m264\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (*q).q[0 as usize],\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdereference of raw pointer\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\u001b[0m\n\n"}
{"message":"dereference of raw pointer is unsafe and requires unsafe function or block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `allow` by default but will be upgraded to `warn` in a future edition.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6909,"byte_end":6927,"line_start":264,"line_end":264,"column_start":9,"column_end":27,"is_primary":true,"text":[{"text":"        (*q).q[0 as usize],","highlight_start":9,"highlight_end":27}],"label":"dereference of raw pointer","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/c00834010/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":2440,"byte_end":2470,"line_start":81,"line_end":81,"column_start":28,"column_end":58,"is_primary":false,"text":[{"text":"        $crate::io::_print($crate::format_args!($($arg)*));","highlight_start":28,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":6863,"byte_end":7017,"line_start":262,"line_end":268,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    print!(","highlight_start":5,"highlight_end":12},{"text":"        \"({}, {}, {}, {})\\n\",","highlight_start":1,"highlight_end":30},{"text":"        (*q).q[0 as usize],","highlight_start":1,"highlight_end":28},{"text":"        (*q).q[1 as usize],","highlight_start":1,"highlight_end":28},{"text":"        (*q).q[2 as usize],","highlight_start":1,"highlight_end":28},{"text":"        (*q).q[3 as usize]","highlight_start":1,"highlight_end":27},{"text":"    );","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"print!","def_site_span":{"file_name":"/home/c00834010/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":2368,"byte_end":2386,"line_start":79,"line_end":79,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! print {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::format_args!","def_site_span":{"file_name":"/home/c00834010/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":29975,"byte_end":29999,"line_start":876,"line_end":876,"column_start":5,"column_end":29,"is_primary":false,"text":[{"text":"    macro_rules! format_args {","highlight_start":5,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0133]\u001b[0m\u001b[0m\u001b[1m: dereference of raw pointer is unsafe and requires unsafe function or block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:264:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m264\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (*q).q[0 as usize],\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdereference of raw pointer\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::format_args` which comes from the expansion of the macro `print` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"dereference of raw pointer is unsafe and requires unsafe function or block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `allow` by default but will be upgraded to `warn` in a future edition.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6937,"byte_end":6955,"line_start":265,"line_end":265,"column_start":9,"column_end":27,"is_primary":true,"text":[{"text":"        (*q).q[1 as usize],","highlight_start":9,"highlight_end":27}],"label":"dereference of raw pointer","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0133]\u001b[0m\u001b[0m\u001b[1m: dereference of raw pointer is unsafe and requires unsafe function or block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:265:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m265\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (*q).q[1 as usize],\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdereference of raw pointer\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\u001b[0m\n\n"}
{"message":"dereference of raw pointer is unsafe and requires unsafe function or block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `allow` by default but will be upgraded to `warn` in a future edition.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6937,"byte_end":6955,"line_start":265,"line_end":265,"column_start":9,"column_end":27,"is_primary":true,"text":[{"text":"        (*q).q[1 as usize],","highlight_start":9,"highlight_end":27}],"label":"dereference of raw pointer","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/c00834010/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":2440,"byte_end":2470,"line_start":81,"line_end":81,"column_start":28,"column_end":58,"is_primary":false,"text":[{"text":"        $crate::io::_print($crate::format_args!($($arg)*));","highlight_start":28,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":6863,"byte_end":7017,"line_start":262,"line_end":268,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    print!(","highlight_start":5,"highlight_end":12},{"text":"        \"({}, {}, {}, {})\\n\",","highlight_start":1,"highlight_end":30},{"text":"        (*q).q[0 as usize],","highlight_start":1,"highlight_end":28},{"text":"        (*q).q[1 as usize],","highlight_start":1,"highlight_end":28},{"text":"        (*q).q[2 as usize],","highlight_start":1,"highlight_end":28},{"text":"        (*q).q[3 as usize]","highlight_start":1,"highlight_end":27},{"text":"    );","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"print!","def_site_span":{"file_name":"/home/c00834010/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":2368,"byte_end":2386,"line_start":79,"line_end":79,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! print {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::format_args!","def_site_span":{"file_name":"/home/c00834010/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":29975,"byte_end":29999,"line_start":876,"line_end":876,"column_start":5,"column_end":29,"is_primary":false,"text":[{"text":"    macro_rules! format_args {","highlight_start":5,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0133]\u001b[0m\u001b[0m\u001b[1m: dereference of raw pointer is unsafe and requires unsafe function or block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:265:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m265\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (*q).q[1 as usize],\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdereference of raw pointer\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::format_args` which comes from the expansion of the macro `print` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"dereference of raw pointer is unsafe and requires unsafe function or block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `allow` by default but will be upgraded to `warn` in a future edition.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6965,"byte_end":6983,"line_start":266,"line_end":266,"column_start":9,"column_end":27,"is_primary":true,"text":[{"text":"        (*q).q[2 as usize],","highlight_start":9,"highlight_end":27}],"label":"dereference of raw pointer","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0133]\u001b[0m\u001b[0m\u001b[1m: dereference of raw pointer is unsafe and requires unsafe function or block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:266:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m266\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (*q).q[2 as usize],\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdereference of raw pointer\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\u001b[0m\n\n"}
{"message":"dereference of raw pointer is unsafe and requires unsafe function or block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `allow` by default but will be upgraded to `warn` in a future edition.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6965,"byte_end":6983,"line_start":266,"line_end":266,"column_start":9,"column_end":27,"is_primary":true,"text":[{"text":"        (*q).q[2 as usize],","highlight_start":9,"highlight_end":27}],"label":"dereference of raw pointer","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/c00834010/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":2440,"byte_end":2470,"line_start":81,"line_end":81,"column_start":28,"column_end":58,"is_primary":false,"text":[{"text":"        $crate::io::_print($crate::format_args!($($arg)*));","highlight_start":28,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":6863,"byte_end":7017,"line_start":262,"line_end":268,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    print!(","highlight_start":5,"highlight_end":12},{"text":"        \"({}, {}, {}, {})\\n\",","highlight_start":1,"highlight_end":30},{"text":"        (*q).q[0 as usize],","highlight_start":1,"highlight_end":28},{"text":"        (*q).q[1 as usize],","highlight_start":1,"highlight_end":28},{"text":"        (*q).q[2 as usize],","highlight_start":1,"highlight_end":28},{"text":"        (*q).q[3 as usize]","highlight_start":1,"highlight_end":27},{"text":"    );","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"print!","def_site_span":{"file_name":"/home/c00834010/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":2368,"byte_end":2386,"line_start":79,"line_end":79,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! print {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::format_args!","def_site_span":{"file_name":"/home/c00834010/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":29975,"byte_end":29999,"line_start":876,"line_end":876,"column_start":5,"column_end":29,"is_primary":false,"text":[{"text":"    macro_rules! format_args {","highlight_start":5,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0133]\u001b[0m\u001b[0m\u001b[1m: dereference of raw pointer is unsafe and requires unsafe function or block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:266:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m266\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (*q).q[2 as usize],\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdereference of raw pointer\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::format_args` which comes from the expansion of the macro `print` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"dereference of raw pointer is unsafe and requires unsafe function or block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `allow` by default but will be upgraded to `warn` in a future edition.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6993,"byte_end":7011,"line_start":267,"line_end":267,"column_start":9,"column_end":27,"is_primary":true,"text":[{"text":"        (*q).q[3 as usize]","highlight_start":9,"highlight_end":27}],"label":"dereference of raw pointer","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0133]\u001b[0m\u001b[0m\u001b[1m: dereference of raw pointer is unsafe and requires unsafe function or block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:267:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m267\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (*q).q[3 as usize]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdereference of raw pointer\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\u001b[0m\n\n"}
{"message":"dereference of raw pointer is unsafe and requires unsafe function or block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `allow` by default but will be upgraded to `warn` in a future edition.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":6993,"byte_end":7011,"line_start":267,"line_end":267,"column_start":9,"column_end":27,"is_primary":true,"text":[{"text":"        (*q).q[3 as usize]","highlight_start":9,"highlight_end":27}],"label":"dereference of raw pointer","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/c00834010/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":2440,"byte_end":2470,"line_start":81,"line_end":81,"column_start":28,"column_end":58,"is_primary":false,"text":[{"text":"        $crate::io::_print($crate::format_args!($($arg)*));","highlight_start":28,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":6863,"byte_end":7017,"line_start":262,"line_end":268,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    print!(","highlight_start":5,"highlight_end":12},{"text":"        \"({}, {}, {}, {})\\n\",","highlight_start":1,"highlight_end":30},{"text":"        (*q).q[0 as usize],","highlight_start":1,"highlight_end":28},{"text":"        (*q).q[1 as usize],","highlight_start":1,"highlight_end":28},{"text":"        (*q).q[2 as usize],","highlight_start":1,"highlight_end":28},{"text":"        (*q).q[3 as usize]","highlight_start":1,"highlight_end":27},{"text":"    );","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"print!","def_site_span":{"file_name":"/home/c00834010/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":2368,"byte_end":2386,"line_start":79,"line_end":79,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! print {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::format_args!","def_site_span":{"file_name":"/home/c00834010/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":29975,"byte_end":29999,"line_start":876,"line_end":876,"column_start":5,"column_end":29,"is_primary":false,"text":[{"text":"    macro_rules! format_args {","highlight_start":5,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0133]\u001b[0m\u001b[0m\u001b[1m: dereference of raw pointer is unsafe and requires unsafe function or block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:267:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m267\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (*q).q[3 as usize]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdereference of raw pointer\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::format_args` which comes from the expansion of the macro `print` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":6789,"byte_end":6795,"line_start":257,"line_end":257,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_unsafe)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:257:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m257\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    unsafe {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_unsafe)]` on by default\u001b[0m\n\n"}
{"message":"aborting due to 8 previous errors; 4 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 8 previous errors; 4 warnings emitted\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0133`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0133`.\u001b[0m\n"}
